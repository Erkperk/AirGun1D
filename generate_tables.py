#!/usr/bin/env python3
"""
Generate thermodynamic tables for the C airgun solver from CoolProp.

Gas: Pure methane (CH4)
  Molar mass: 16.043 g/mol
  Critical point: Tc = 190.564 K, Pc = 45.992 bar

Outputs:
  tables.h  -- U(T,P) and Cv(T,P) tables for the C solver
"""
import numpy as np
import CoolProp.CoolProp as CP

FLUID = "Methane"
MOLAR_MASS = 16.043  # g/mol
print(f"Fluid: {FLUID}")
print(f"Molar mass: {MOLAR_MASS:.4f} g/mol")

# Grid
T_grid = np.arange(150.0, 501.0, 2.0)  # 176 points: 150, 152, ..., 500
P_grid = np.arange(1e4, 2.001e7, 5e4)  # 400 points: 10000, 60000, ..., 20000000
NT = len(T_grid)
NP = len(P_grid)
print(f"Grid: {NT} T points x {NP} P points")
print(f"T range: {T_grid[0]:.0f} - {T_grid[-1]:.0f} K")
print(f"P range: {P_grid[0]:.0f} - {P_grid[-1]:.0f} Pa")

# Allocate tables
U_tab = np.zeros((NT, NP))
Cv_tab = np.zeros((NT, NP))

n_fail = 0
for i, T in enumerate(T_grid):
    if i % 20 == 0:
        print(f"  T = {T:.0f} K ({i+1}/{NT})...")
    for j, P in enumerate(P_grid):
        try:
            U_tab[i, j] = CP.PropsSI('U', 'T', T, 'P', P, FLUID)   # J/kg
            Cv_tab[i, j] = CP.PropsSI('Cvmass', 'T', T, 'P', P, FLUID)  # J/(kg*K)
        except Exception:
            U_tab[i, j] = np.nan
            Cv_tab[i, j] = np.nan
            n_fail += 1

print(f"Completed: {n_fail} failed points (two-phase region)")

# Mark physically unreasonable entries as bad (near-critical CoolProp artifacts)
bad_cv = np.isnan(Cv_tab) | (Cv_tab <= 0) | (Cv_tab < 500)
bad_u = np.isnan(U_tab) | (U_tab == 0)
bad = bad_cv | bad_u
n_bad = np.sum(bad)
print(f"Bad entries (NaN, Cv<=0, Cv<500, U==0): {n_bad}")

# Fill bad entries by averaging valid neighbors (iterative, up to 10 passes)
for tab, name in [(U_tab, "U"), (Cv_tab, "Cv")]:
    mask = np.isnan(tab) | (tab == 0) if name == "U" else np.isnan(tab) | (tab <= 0) | (tab < 500)
    for iteration in range(10):
        filled = 0
        for i in range(NT):
            for j in range(NP):
                if not mask[i, j]:
                    continue
                vals = []
                for di, dj in [(-1,0),(1,0),(0,-1),(0,1),(-1,-1),(-1,1),(1,-1),(1,1)]:
                    ni, nj = i + di, j + dj
                    if 0 <= ni < NT and 0 <= nj < NP and not mask[ni, nj]:
                        vals.append(tab[ni, nj])
                if vals:
                    tab[i, j] = np.mean(vals)
                    mask[i, j] = False
                    filled += 1
        if filled == 0:
            break
        print(f"  {name}: pass {iteration+1}, filled {filled} entries")

# Verify no bad entries remain
assert np.all(Cv_tab > 0), "Cv table still has non-positive entries!"
assert np.all(~np.isnan(U_tab)), "U table still has NaN entries!"
print("All table entries are valid.")

# Write tables.h
def write_c_table(f, name, data, nrows, ncols):
    f.write(f"static const double {name}[{nrows}][{ncols}] = {{\n")
    for i in range(nrows):
        f.write("  {")
        for j in range(ncols):
            val = data[i, j]
            if j > 0:
                f.write(", ")
            f.write(f"{val:.6f}")
        f.write("}")
        if i < nrows - 1:
            f.write(",")
        f.write("\n")
    f.write("};\n\n")

with open('tables.h', 'w') as f:
    f.write("/* Auto-generated by generate_tables.py -- do not edit */\n")
    f.write("/* Gas: Pure methane (CH4) */\n")
    f.write(f"/* Molar mass: {MOLAR_MASS:.4f} g/mol */\n\n")
    f.write("#ifndef TABLES_H\n#define TABLES_H\n\n")
    f.write(f"#define NT {NT}\n")
    f.write(f"#define NP {NP}\n")
    f.write(f"#define T_MIN {T_grid[0]:.1f}\n")
    f.write(f"#define T_STEP 2.0\n")
    f.write(f"#define P_MIN {P_grid[0]:.1f}\n")
    f.write(f"#define P_STEP 50000.0\n\n")
    write_c_table(f, 'U_table', U_tab, NT, NP)
    write_c_table(f, 'Cv_table', Cv_tab, NT, NP)
    f.write("#endif /* TABLES_H */\n")

print("Saved: tables.h")

# Print reference values for verification
R_spec = 8314.46 / MOLAR_MASS
T_ref, P_ref = 288.0, 164e5
rho_ref = CP.PropsSI('D', 'T', T_ref, 'P', P_ref, FLUID)
a_ref = CP.PropsSI('A', 'T', T_ref, 'P', P_ref, FLUID)
print(f"\nReference point (T={T_ref}K, P={P_ref/1e5:.0f} bar):")
print(f"  rho  = {rho_ref:.2f} kg/m3")
print(f"  U    = {CP.PropsSI('U', 'T', T_ref, 'P', P_ref, FLUID):.1f} J/kg")
print(f"  Cv   = {CP.PropsSI('Cvmass', 'T', T_ref, 'P', P_ref, FLUID):.1f} J/(kg*K)")
print(f"  Cp   = {CP.PropsSI('Cpmass', 'T', T_ref, 'P', P_ref, FLUID):.1f} J/(kg*K)")
print(f"  a    = {a_ref:.1f} m/s")
Z_ref = P_ref / (rho_ref * R_spec * T_ref)
print(f"  Z    = {Z_ref:.6f}")
print(f"  R    = {R_spec:.4f} J/(kg*K)")
